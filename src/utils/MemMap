#!/bin/bash

usage()
{
    echo "Usage : $0 [options] -c \"command\""
    echo "Loads MemMap kernel module and configure it to monitor command, then
    execute the command given by the user"
    echo "-c cmd            The command to be executed"
    echo "Options:"
    echo "-w    interval    Set the wakeup interval for MemMap to interval ms,
    default: $interval"
    echo "-a \"args\"       The arguments for command"
    echo "-h                Display this help and exit"
    echo "-p prio           Schedtool priority for the kernel module, the user
    program priority will be prio-1, default: $prio"
    echo "-d dir            Path to the MemMap dir default $install_dir"
    echo "-f file           Log cmd into file"
    echo "-l file           Log module output into file"
    echo "-b numbits        Set the number of bits used for the chunk hashmaps we
    can store up to Factor*2^numbits different adress in one
    chunk"
    echo "-F factor         This settings allow you to increase the maximum
    number of adress per chunks without changing the
    number of bits used for the hashmap"
    echo "-C nbChunks       Set the number of chunks to keep in memory.
    We can increase this number to avoid loosing data,
    however the more chunks we keep, the more memory
    we use ... If you don't see a message in your log
    telling you that you may have lost some data, you
    really shouldn't touch this parameter"
}

which schedtool > /dev/null
if [ $? -ne 0 ]
then
    echo "$0 requires the schedtool which is not find in your PATH"
    echo "Please install schedtool or update your PATH"
    exit 1
fi

if [ $(whoami) != "root"  ]
then
    echo "$0 must be run as root"
    exit 1
fi

prio=$(schedtool -r | grep FIFO | sed -e 's/.*prio_max \([0-9]*\)/\1/')
install_dir="~/install/MemMap"
kernLogFile="MemMap"
procdir="/proc/MemMap"
log_thread_interval=.005

while getopts "w:c:a:hp:d:f:l:F:b:C:" opt
do
    case $opt in
        h)
            usage
            exit 0
            ;;
        w)
            memmap_interval="MemMap_wakeupInterval=$OPTARG"
            ;;
        a)
            args="$OPTARG"
            ;;
        c)
            cmd="$OPTARG"
            ;;
        p)
            prio=$OPTARG
            ;;
        d)
            install_dir="$OPTARG"
            ;;
        f)
            logfile="$OPTARG"
            ;;
        l)
            kernLogFile="$OPTARG"
            ;;
        b)
            memmap_bits="MemMap_taskDataHashBits=$OPTARG"
            ;;
        F)
            memmap_factor="MemMap_taskDataTableFactor=$OPTARG"
            ;;
        C)
            memmap_chunks="MemMap_nbChunks=$OPTARG"
            ;;
        *)
            usage
            exit 1
            ;;
    esac
done

if [ -z "$cmd" ]
then
    echo "A command is required"
    usage
    exit 1
fi

# Wait for the kernel module to start
child()
{
    #echo "Child $BASHPID waiting for a signal from my parent"
    kill -s SIGSTOP $BASHPID
    #echo "Child $BASHPID awake"
    if [ -z "$logfile" ]
    then
        $cmd $args
    else
        $cmd $args > $logfile 2> $logfile.err
    fi
    ret=$?
    echo "$cmd ended code $ret"
    exit $ret
}
log()
{
    while test -e $procdir
    do
        for f in $(\ls $procdir)
        do
            cat $procdir/$f >> $kernLogFile-$f.log
            sleep $log_thread_interval
        done
    done
}

abort_on_error()
{
    if [ $1 -ne 0 ]
    then
        kill -9 $pid
        echo "Fatal error: $2"
        echo "aborting"
        exit 1
    fi
}

let user_prio=$(( $prio - 1 ))
child &
pid=$!
schedtool -F -p $prio $$
schedtool -F -p $user_prio $pid
cd $install_dir/src/module/
make clean && make
abort_on_error $? "make fail"
# make install
# abort_on_error $? "Install fail"
insmod memmap.ko MemMap_mainPid=$pid MemMap_schedulerPriority=$prio \
    $memmap_interval $memmap_bits $memmap_factor $memmap_chunks
abort_on_error $? "unable to load module"
cd -
log &
logpid=$!
schedtool -F -p $prio $logpid
kill -s SIGCONT $pid
#echo "Parent $BASHPID waiting for child $pid in script $$"
wait $pid
rmmod memmap
